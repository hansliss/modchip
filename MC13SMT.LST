
AVRASM ver. 1.21  MC13SMT.ASM Sun May 13 20:33:05 2001


         ;***************************************************************************
         ;* Playstation Import enabler code
         ;* 
         ;* File Name            :modchip.asm
         ;* Title                :Playstation Import enabler code
         ;* Date                 :99-04-22
         ;* Version              :1.3
         ;* Support email        :Hans@Liss.pp.se
         ;* Target MCU           :AT90S1200
         ;* Clock type		:2MHz ceramic resonator or equiv.
         ;*
         ;* DESCRIPTION
         ;*
         ;* This code will send a Playstation region code (four characters - SCEE
         ;* for Europe, SCEI for Japan and SCEA for the US) as a serial bitstream
         ;* at about 250bps on an I/O pin, for a short time after RESET. It also
         ;* acts as a software jumper between two lines, and can handle blanking of
         ;* another signal. All these signals will go tristate after a certain time
         ;* to hide the chip. The processor will restart when the lid is opened and
         ;* closed and when the RESET switch is pressed and released.
         ;*
         ;* There is an option of connecting a pair of switches against GND to two
         ;* pins, and they can then be used to select between three different CNT
         ;* values, or disable the chip completely. The status of the switches is
         ;* read every time the sequence is to be started.
         ;*
         ;* A three-legged, dual-colour LED can be connected to two of the I/O pins
         ;* and GND.
         ;* It will then be used to show what the processor is doing - cycling
         ;* between colours when the code is being sent, turning green when it's
         ;* ready, turning red when disabled and yellow during a pending RESET or
         ;* media change.
         ;*
         ;*                       Processor chip layout
         ;*
         ;*	                      -----v-----
         ;*                         1 [|o        |] 20   Vcc
         ;*		Lid        2 [|         |] 19   
         ;*		Reset      3 [|         |] 18   
         ;*                         4 [|         |] 17   
         ;*                         5 [|         |] 16   Calibrate
         ;*              Blanking   6 [|         |] 15   LED
         ;*              Data OUT   7 [|         |] 14   
         ;*	        Jumper IN  8 [|         |] 13   Switch 2
         ;*	        Jumper OUT 9 [|         |] 12   Switch 1
         ;*              GND       10 [|         |] 11
         ;*                            -----------
         ;*
         ;*
         ;* This code is inspired by Scott Rider's widely distributed modchip code for
         ;* the PIC 12C508. The Atmel chip is far better at most of these things - 
         ;* many more registers and much more orthogonal instruction set along with
         ;* four times the speed of a comparable PIC. The AT90S1200 is, however, more
         ;* expensive than the 12C508, but OTOH it has lots more I/O pins,
         ;* making all these bells and whistles possible. And programming it is fun!
         ;* I am working with Atmels own "wavrasm" which as far as I know is 
         ;* available on their home page on <http://www.atmel.com>.
         ;*
         ;* Going back to Scott Rider, we can define a mapping between the pin
         ;* connections for his code, which appears to be the same for most of the
         ;* commercially available chips. Pin 1 on the PIC is Vdd, 0-7V, and pin 8 is
         ;* GND. Pin 5 is used for the "blanking" signal, to block the real data from
         ;* the CD unit. Pin 6 is the serial data stream.
         ;* This means that going from a 12C508 to a AT90S1200 gives the following mapping:
         ;*
         ;*    From pin    To pin
         ;*           1 -> 20
         ;*           5 -> 6
         ;*           6 -> 7
         ;*           8 -> 10
         ;*
         ;* This code was made for a modern PU-22 motherboard, which is handled
         ;* somewhat differently. Instead of pin 5 on the 12C508, here we usually have
         ;* a jumper cable between two positions on the board. In this solution,
         ;* the LEFT one of these points should be connected to "Jumper IN", and
         ;* the RIGHT one to "Jumper OUT".
         ;* You can leave the jumper in there but then the chip can never be
         ;* completely hidden, which may or may not be significant.
         ;*
         ;* Where to find the RESET and Lid signals on an old motherboard is left as
         ;* an excercise for the reader. All I know is that the Lid signal was usually
         ;* pin 4 on the older, 18 pin 16c84 modchips.
         ;*
         ;* More info and pictures can be found on <http://www.maxking.com>.
         ;* On the PU-22 board, the CD Lid signal is the one close to the CD connector,
         ;* and the RESET signal can be found on the upper half of the board.
         ;*
         ;* ********* *NEW for version 1.1 ***************
         ;* I have cleaned up the delay sections and created a single delay function,
         ;* together with a matching macro, WAITMS. Now the chip will read its delay
         ;* constants from the EEPROM making it tunable to different chip speeds.
         ;* There is also a subroutine "calibrate" that can be used to calibrate the
         ;* delay loop. Connect a pushbutton between earth and pin 19 on the chip. Keep
         ;* this pressed when starting the Playstation and keep it pressed for exactly
         ;* 10 seconds, then release it. The new delay constants will be calculated
         ;* and stored into the EEPROM.
         ;*
         ;* ********* *NEW for version 1.2 ***************
         ;* I have remade some of the Count handling. There are still three different
         ;* Count values available, selectable with the switch. Now, however, it is
         ;* possible to change those values. To _decrease_ the current count value,
         ;* simply boot a game and press the Calibrate button whenever you think
         ;* that enough pulses have passed, usually just after the copyright screen
         ;* has disappeared and turned black. To _increase_ the value, wait until the
         ;* end of the cycle and then press the button. The current Count will increase
         ;* by ten.
         ;* There is now also a way to easily recalibrate the speed with a default value
         ;* for 5V. Just do a normal calibration but release the button almost immediately,
         ;* and the calibration values will be set to 115 and 103, respectively (my
         ;* calculated values).
         ;*
         ;* ********* *NEW for version 1.2.1 ***************
         ;* Added debounce to lid and RESET switches. Added weak pullup to RESET input
         ;*
         ;* ********* *NEW for version 1.3   ***************
         ;* The default timing is now calibrated for an AT90S1200 with a 2MHz ceramic
         ;* resonator, and the default Count value is calibrated for Final Fantasy VIII,
         ;* which works just fine with this code. All the features are still there but
         ;* they are mostly unnecessary now..
         ;*
         ;***************************************************************************
         
          .device	AT90S1200	;Prohibits use of non-implemented instructions
         
          .include "1200def.inc"
         ;***************************************************************************
         ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
         ;* 
         ;* Number		:AVR000
         ;* File Name		:"1200def.inc"
         ;* Title		:Register/Bit Definitions for the AT90S1200
         ;* Date	 		:97.12.11
         ;* Version		:1.20
         ;* Support telephone	:+47 72 88 87 20 (ATMEL Norway)
         ;* Support fax		:+47 72 88 87 18 (ATMEL Norway)
         ;* Support E-Mail	:avr@atmel.com
         ;* Target MCU		:AT90S1200
         ;*
         ;* DESCRIPTION
         ;* When including this file in the assembly program file, all I/O register
         ;* names and I/O register bit names appearing in the data book can be used.
         ;* 
         ;* The Register names are represented by their hexadecimal addresses.
         ;* 
         ;* The Register Bit names are represented by their bit number (0-7).
         ;* 
         ;* Please observe the difference in using the bit names with instructions
         ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc" 
         ;* (skip if bit in register set/cleared). The following example illustrates
         ;* this:
         ;* 
         ;* in	r16,PORTB		;read PORTB latch
         ;* sbr	r16,(1<<PB6)+(1<<PB5)	;set PB6 and PB5 (use masks, not bit#)
         ;* out  PORTB,r16		;output to PORTB
         ;*
         ;* in	r16,TIFR		;read the Timer Interrupt Flag Register
         ;* sbrc	r16,TOV0		;test the overflow flag (use bit#)
         ;* rjmp	TOV0_is_set		;jump if set
         ;* ...				;otherwise do something else
         ;***************************************************************************
         
         ;***** Specify Device
          .device AT90S1200
         
         ;***** I/O Register Definitions
          .equ	SREG	=$3f
          .equ	GIMSK	=$3b
          .equ	TIMSK	=$39
          .equ	TIFR	=$38
          .equ	MCUCR	=$35
          .equ	TCCR0	=$33
          .equ	TCNT0	=$32
          .equ	WDTCR	=$21
          .equ	EEAR	=$1e
          .equ	EEDR	=$1d
          .equ	EECR	=$1c
          .equ	PORTB	=$18
          .equ	DDRB	=$17
          .equ	PINB	=$16
          .equ	PORTD	=$12
          .equ	DDRD	=$11
          .equ	PIND	=$10
          .equ	ACSR	=$08
         
         ;***** Bit Definitions
         
          .equ	INT0	=6
         
          .equ	TOIE0	=1
         
          .equ	TOV0	=1
         
          .equ	SE	=5
          .equ	SM	=4
          .equ	ISC01	=1
          .equ	ISC00	=0
         
          .equ	CS02	=2
          .equ	CS01	=1
          .equ	CS00	=0
         
          .equ	WDE	=3
          .equ	WDP2	=2
          .equ	WDP1	=1
          .equ	WDP0	=0
         
          .equ	EEWE	=1
          .equ	EERE	=0
         
          .equ	PB7	=7
          .equ	PB6	=6
          .equ	PB5	=5
          .equ	PB4	=4
          .equ	PB3	=3
          .equ	PB2	=2
          .equ	PB1	=1
          .equ	PB0	=0
         
          .equ	DDB7	=7
          .equ	DDB6	=6
          .equ	DDB5	=5
          .equ	DDB4	=4
          .equ	DDB3	=3
          .equ	DDB2	=2
          .equ	DDB1	=1
          .equ	DDB0	=0
         
          .equ	PINB7	=7
          .equ	PINB6	=6
          .equ	PINB5	=5
          .equ	PINB4	=4
          .equ	PINB3	=3
          .equ	PINB2	=2
          .equ	PINB1	=1
          .equ	PINB0	=0
         
          .equ	PD6	=6
          .equ	PD5	=5
          .equ	PD4	=4
          .equ	PD3	=3
          .equ	PD2	=2
          .equ	PD1	=1
          .equ	PD0	=0
         
          .equ	DDD6	=6
          .equ	DDD5	=5
          .equ	DDD4	=4
          .equ	DDD3	=3
          .equ	DDD2	=2
          .equ	DDD1	=1
          .equ	DDD0	=0
         
          .equ	PIND6	=6
          .equ	PIND5	=5
          .equ	PIND4	=4
          .equ	PIND3	=3
          .equ	PIND2	=2
          .equ	PIND1	=1
          .equ	PIND0	=0
         
          .equ	ACD	=7
          .equ	ACO	=5
          .equ	ACI	=4
          .equ	ACIE	=3
          .equ	ACIS1	=1
          .equ	ACIS0	=0
         
          .equ	INT0addr=$001	;External Interrupt0 Vector Address
          .equ	OVF0addr=$002	;Overflow0 Interrupt Vector Address
          .equ	ACIaddr =$003	;Analog Comparator Interrupt Vector Address
         
          .def	ZL	=r30
         
          .LISTMAC
         
         ;***** Global Register Variables
         
         
         ;***** Arg registers
          .def	A1	=r16
          .def	A2	=r17
          .def	A3	=r18
          .def	CNT	=r19
          .def	D1	=r28
          .def	D2	=r29
          .def	X	=r30
          .def	curC	=r23
         
         ;***** Scratch regs
          .def	I	=r20
          .def	J	=r21
          .def	K	=r22
         
         ;***** EEPROM vars
          .equ	storedD1=0
          .equ	storedD2=1
          .equ	storedC1=2
          .equ	storedC2=3
          .equ	storedC3=4
         
         ;.equ	defaultD1=115
         ;.equ	defaultD2=103
          .equ	defaultD1=$FE
          .equ	defaultD2=$FD
          .equ	defaultC=100
         
         ;******* PORT B
         
         ;  Switches - active low: 0=off, 1=Use COUNT1, 2=Use COUNT2, 3=Use COUNT3
          .equ	SWITCH1=0
          .equ	SWITCH2=1
         
          .equ	SWITCH3=4
         
         ;  Red and green LED ouput pins
          .equ	LEDBIT=3
         ;.equ	GLEDBIT=6
         
         ;******* PORT D
         
         ;  Media change signal, active high input
          .equ	LSIG=0
         
         ;  Reset signal, active low input
          .equ	RSIG=1
         
         ;  "Blanking" signal - extra pin for old PSX 4-line chips
          .equ	BLANK=2
         
         ;  Subchannel data stream, output
          .equ	PORTBIT=3
         
         ;  "Jumper" input
          .equ	JUMPIN=4
         
         ;  "Jumper" output
          .equ	JUMPOUT=5
         
         ;Count values for short and long settings, respectively
          .equ	COUNT1=172
          .equ	COUNT2=186
          .equ	COUNT3=198
         
         ;***** Macros
          .macro	SENDONE
          	cbi	DDRD,PORTBIT
          .endmacro
         
          .macro	SENDZERO
          	sbi	DDRD,PORTBIT
          .endmacro
         
          .macro	LIGHTBOTH
          	sbi	DDRB,LEDBIT
          .endmacro
         
          .macro	LIGHTRED
          	sbi	DDRB,LEDBIT
          .endmacro
         
          .macro	LIGHTGRN
          	cbi	DDRB,LEDBIT
          .endmacro
         
          .macro	LIGHTOFF
          	cbi	DDRB,LEDBIT
          .endmacro
         
          .macro	WAITMS
          	ldi	X,@0
          	rcall	waitxms
          .endmacro
         
         ; Execute the software "jumper". Five cycles.
          .macro	DOJUMP
          	sbis	PIND,JUMPIN
          	sbi	DDRD,JUMPOUT
          	sbic	PIND,JUMPIN
          	cbi	DDRD,JUMPOUT
          .endmacro
         
          .macro	ENBLANK
          	cbi	PORTD,BLANK
          	sbi	DDRD,BLANK
          .endmacro
         
          .macro	DEBLANK
          	cbi	PORTD,BLANK
          	cbi	DDRD,BLANK
          .endmacro
         
         ;***** Code
         
000000 c11d      	rjmp	START		;Reset Handle
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'waitxms'
         ;*
         ;* Stored vars D1 and D2 is used for calibration.
         ;*
         ;* This subroutine will wait for x ms minus one LDI+call+return.
         ;* The innermost loop is D1 * (5 + 1 + 1 + 2) cycles. We execute that loop
         ;* (+ 3 cycles for DEC+BRNI) X-1 times, and then we do the rest minus 8 cycles
         ;* in a separate loop (D2 * (5 + 1 + 1 + 1 + 2)). This leaves 8 cycles = 7 for
         ;* call/return and one for the necessary LDI X,# instruction.
         ;*
         ;***************************************************************************
         
         
          waitxms:
000001 95ea      	dec	X
000002 f089      	breq	vxloop20
          wxloop0:
000003 2f4c      	mov	I,d1
          wxloop1:
000004   +  	DOJUMP
000004 9b84      	sbis	PIND,JUMPIN
000005 9a8d      	sbi	DDRD,JUMPOUT
000006 9984      	sbic	PIND,JUMPIN
000007 988d      	cbi	DDRD,JUMPOUT
          .endmacro
000008 0000      	nop
000009 0000      	nop
00000a 0000      	nop
00000b 0000      	nop
00000c 0000      	nop
00000d 0000      	nop
00000e 0000      	nop
00000f 0000      	nop
000010 954a      	dec	I
000011 f791      	brne	wxloop1
         
000012 95ea      	dec	X
000013 f779      	brne	wxloop0
         
          vxloop20:
000014 2f4d      	mov	I,d2
          wxloop2:
000015   +  	DOJUMP
000015 9b84      	sbis	PIND,JUMPIN
000016 9a8d      	sbi	DDRD,JUMPOUT
000017 9984      	sbic	PIND,JUMPIN
000018 988d      	cbi	DDRD,JUMPOUT
          .endmacro
000019 0000      	nop
00001a 0000      	nop
00001b 0000      	nop
00001c 0000      	nop
00001d 0000      	nop
00001e 0000      	nop
00001f 0000      	nop
000020 0000      	nop
000021 0000      	nop
000022 954a      	dec	I
000023 f789      	brne	wxloop2
         
000024 9508      	ret
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'calibrate', called from sysinit
         ;*
         ;* Do 10000 cycles each loop, increasing r24:r25 by one each pass.
         ;* This subroutine will calibrate 1 ms if run during 10 sec. The switch on
         ;* SWITCH3 is checked for release on every pass.
         ;*
         ;* 'makecns' will calculate the delay constants d1 and d2 as follows:
         ;* 	d1=(n-3)/9
         ;* 	d2=(n-8)/10
         ;* and then store them to the EEPROM
         ;*
         ;****************************************************************************
         
          calibrate:
000025   +  	LIGHTRED
000025 9abb      	sbi	DDRB,LEDBIT
          .endmacro
000026 e080      	ldi	r24,0
000027 e090      	ldi	r25,0
          cloop0:
000028 99b4      	sbic	PINB,SWITCH3
000029 c00a      	rjmp	makecns
         
00002a e245      	ldi	I,37
          cloop1:
00002b e559      	ldi	J,89
          cloop2:
00002c 955a      	dec	J
00002d f7f1      	brne	cloop2
         
00002e 954a      	dec	I
00002f f7d9      	brne	cloop1
         
000030 9593      	inc	r25
000031 f7b1      	brne	cloop0
000032 9583      	inc	r24
000033 cff4      	rjmp	cloop0
         
          makecns:
000034 5093      	subi	r25,3
000035 4080      	sbci	r24,0
         
          mc01:
000036 2fa8      	mov	r26,r24
000037 2fb9      	mov	r27,r25
000038 e0c0      	ldi	d1,0
          l1:
000039 30a0      	cpi	r26,0
00003a f411      	brne	l12
00003b 30b9      	cpi	r27,9
00003c f020      	brlo	l13
          l12:
00003d 50b9      	subi	r27,9
00003e 40a0      	sbci	r26,0
         
00003f 95c3      	inc	d1
000040 cff8      	rjmp	l1
         
          l13:
000041 5095      	subi	r25,5
000042 4080      	sbci	r24,0
000043 e0d0      	ldi	d2,0
          l2:
000044 3080      	cpi	r24,0
000045 f411      	brne	l22
000046 309a      	cpi	r25,10
000047 f020      	brlo	l23
          l22:
000048 509a      	subi	r25,10
000049 4080      	sbci	r24,0
         
00004a 95d3      	inc	d2
00004b cff8      	rjmp	l2
         
          l23:
         ; ** If d1 is less than 5, we have a value reset at hand and will set
         ; ** the values to a suitable 5V default
00004c 31ce      	cpi	d1,30
00004d f488      	brsh	l231
00004e efce      	ldi	d1,defaultD1
00004f efdd      	ldi	d2,defaultD2
000050   +  	LIGHTBOTH
000050 9abb      	sbi	DDRB,LEDBIT
          .endmacro
000051   +  	WAITMS	125
000051 e7ed      	ldi	X,0x7d
000052 dfae      	rcall	waitxms
          .endmacro
000053   +  	LIGHTGRN
000053 98bb      	cbi	DDRB,LEDBIT
          .endmacro
000054   +  	WAITMS	125
000054 e7ed      	ldi	X,0x7d
000055 dfab      	rcall	waitxms
          .endmacro
000056   +  	LIGHTBOTH
000056 9abb      	sbi	DDRB,LEDBIT
          .endmacro
000057   +  	WAITMS	125
000057 e7ed      	ldi	X,0x7d
000058 dfa8      	rcall	waitxms
          .endmacro
000059   +  	LIGHTGRN
000059 98bb      	cbi	DDRB,LEDBIT
          .endmacro
00005a   +  	WAITMS	125
00005a e7ed      	ldi	X,0x7d
00005b dfa5      	rcall	waitxms
          .endmacro
00005c   +  	LIGHTBOTH
00005c 9abb      	sbi	DDRB,LEDBIT
          .endmacro
00005d   +  	WAITMS	125
00005d e7ed      	ldi	X,0x7d
00005e dfa2      	rcall	waitxms
          .endmacro
          l231:
         ;	ldi	I,storedD1
         ;	out	EEAR,I
         ;	out	EEDR,d1
         ;	sbi	EECR,EEWE
         ;l24:
         ;	sbic	EECR,EEWE
         ;	rjmp	l24
         
         ;	ldi	I,storedD2
         ;	out	EEAR,I
         ;	out	EEDR,d2
         ;	sbi	EECR,EEWE
         
00005f   +  	LIGHTGRN
00005f 98bb      	cbi	DDRB,LEDBIT
          .endmacro
000060 c079      	rjmp	cont
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'sendbyte'
         ;*
         ;* This subroutine will send one character to the (globally defined) I/O
         ;* port.
         ;* A 'one' is done by making the port bit an input bit and letting the
         ;* PSX pullup pull the line up. A 'zero' is done by making it an output
         ;* - the port bit data is a 'zero' during all this so the only thing
         ;* that changes is the port direction, which is set to 'one' for output
         ;* ('zero'), and 'zero' for input ('one').
         ;* Each bit will take 4 ms, and one start bit and two stop bits will be sent
         ;*
         ;***************************************************************************
         
          sendbyte:
         ; Invert byte
000061 9500      	com	A1
         ; Send a start bit
000062   +  	SENDONE
000062 988b      	cbi	DDRD,PORTBIT
          .endmacro
000063   +  	WAITMS	4
000063 e0e4      	ldi	X,0x4
000064 df9c      	rcall	waitxms
          .endmacro
000065 e018      	ldi	A2,8
000066 9507      sbloop0:ror	A1
000067 f010      	brcs	bitset
000068   +  	SENDZERO
000068 9a8b      	sbi	DDRD,PORTBIT
          .endmacro
000069 f408      	brcc	bitclr
00006a   +  bitset:	SENDONE
00006a 988b      	cbi	DDRD,PORTBIT
          .endmacro
00006b   +  bitclr:	WAITMS	4
00006b e0e4      	ldi	X,0x4
00006c df94      	rcall	waitxms
          .endmacro
00006d 951a      	dec	A2
00006e f7b9      	brne	sbloop0
         ; Send two stop bits
00006f   +  	SENDZERO
00006f 9a8b      	sbi	DDRD,PORTBIT
          .endmacro
000070   +  	WAITMS	4
000070 e0e4      	ldi	X,0x4
000071 df8f      	rcall	waitxms
          .endmacro
000072   +  	WAITMS	4
000072 e0e4      	ldi	X,0x4
000073 df8d      	rcall	waitxms
          .endmacro
000074 9508      	ret
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'sysinit'
         ;*
         ;* This subroutine will initialize the I/O ports and check the switch
         ;* settings
         ;*
         ;* LED is unlit
         ;*
         ;***************************************************************************
         
          sysinit:
         ; Prepare the Reset and Media Change signal inputs (no pullup)
         ; and the SWITCH3 portbit (internal pullup)
000075 9889      	cbi	DDRD,RSIG
000076 9888      	cbi	DDRD,LSIG
000077 9a91      	sbi	PORTD,RSIG
000078 9890      	cbi	PORTD,LSIG
000079 98bc      	cbi	DDRB,SWITCH3
00007a 9ac4      	sbi	PORTB,SWITCH3
         
         ; Set the LED signal as input
00007b 98c3      	cbi	PORTB,LEDBIT
         
         ; Load the stored variables from the EEPROM
         ;	ldi	I,storedD1
         ;	out	EEAR,I
         ;	sbi	EECR,EERE
         ;	in	d1,EEDR
         ;	ldi	I,storedD2
         ;	out	EEAR,I
         ;	sbi	EECR,EERE
         ;	in	d2,EEDR
         
         ;	cpi	d1,255
         ;	brne	sinit00
00007c efce      	ldi	d1,defaultD1
00007d efdd      	ldi	d2,defaultD2
         
          sinit00:
         
         ; Check if the Calibrate switch is pressed
00007e 9bb4      	sbis	PINB,SWITCH3
00007f cfa5      	rjmp	calibrate
         
         ; Check the DIP switch to see whether we should go tristate or which count calue
         ; to select
         ;	cbi	DDRB,SWITCH1
         ;	sbi	PORTB,SWITCH1
         ;	cbi	DDRB,SWITCH2
         ;	sbi	PORTB,SWITCH2
         
         ;	sbic	PINB,SWITCH1
         ;	rjmp	sinit1
         ;	sbis	PINB,SWITCH2
         ;	rjmp	passive
         ;	ldi	curC,storedC2
         ;	rjmp	sinitx
         
         ;sinit1:
         ;	sbic	PINB,SWITCH2
         ;	rjmp	sinit3
         ;	ldi	curC,storedC1
         ;	rjmp	sinitx
         
         ;sinit3:
         ;	ldi	curC,storedC3
         
         ;sinitx:
         ;	out	EEAR,curC
         ;	sbi	EECR,EERE
         ;	in	CNT,EEDR
         
         ;	cpi	CNT,255
         ;	brne	sinitx1
000080 e634      	ldi	CNT,defaultC
         
          sinitx1:
000081   +  	SENDONE
000081 988b      	cbi	DDRD,PORTBIT
          .endmacro
000082 9893      	cbi	PORTD,PORTBIT
         
         
         ; Prepare the "jumper" bits. The input will have a pullup and the output
         ; will assume there is a pullup, and send the bits in the same way as the
         ; data is sent on PORTBIT. 
000083 988d      	cbi	DDRD,JUMPOUT
000084 988c      	cbi	DDRD,JUMPIN
000085 9a94      	sbi	PORTD,JUMPIN
000086 9895      	cbi	PORTD,JUMPOUT
         
000087 e063      	ldi	k,3
000088 9508      	ret
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'init'
         ;*
         ;* This subroutine will wait for 50 ms and then take the I/O port bit low,
         ;* then wait for 1164 ms more before returning. 850 ms into the latter, the
         ;* blanking bit is taken low.
         ;*
         ;***************************************************************************
         
          init:
000089   +  	WAITMS	50
000089 e3e2      	ldi	X,0x32
00008a df76      	rcall	waitxms
          .endmacro
         ;make pin go low as output
00008b   +  	SENDZERO
00008b 9a8b      	sbi	DDRD,PORTBIT
          .endmacro
00008c e111      	ldi	A2,17
00008d   +  iloop1:	WAITMS	50
00008d e3e2      	ldi	X,0x32
00008e df72      	rcall	waitxms
          .endmacro
00008f 951a      	dec	A2
000090 f7e1      	brne	iloop1
000091   +  	ENBLANK
000091 9892      	cbi	PORTD,BLANK
000092 9a8a      	sbi	DDRD,BLANK
          .endmacro
000093 e016      	ldi	A2,6
000094   +  iloop2:	WAITMS	50
000094 e3e2      	ldi	X,0x32
000095 df6b      	rcall	waitxms
          .endmacro
000096 951a      	dec	A2
000097 f7e1      	brne	iloop2
000098   +  	WAITMS	14
000098 e0ee      	ldi	X,0xe
000099 df67      	rcall	waitxms
          .endmacro
00009a 9508      	ret
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'sendcode'
         ;*
         ;* This subroutine will send a four-byte string to the (globally defined)
         ;* I/O port a specified number of times, then return.
         ;*
         ;***************************************************************************
         
          sendcode:
00009b 2f23      	mov	A3,CNT
          scloop0:
00009c d036      	rcall	clight
         
00009d   +  	WAITMS	72
00009d e4e8      	ldi	X,0x48
00009e df62      	rcall	waitxms
          .endmacro
00009f e503      	ldi	A1,'S'
0000a0 dfc0      	rcall	sendbyte
0000a1 e403      	ldi	A1,'C'
0000a2 dfbe      	rcall	sendbyte
0000a3 e405      	ldi	A1,'E'
0000a4 dfbc      	rcall	sendbyte
0000a5 e405      	ldi	A1,'E'
0000a6 dfba      	rcall	sendbyte
         
         
         ; Check if the Calibrate switch is pressed. If it is,
         ; terminate the loop here and store the new value for
         ; this particular COUNT in the EEPROM
         
0000a7 9bb4      	sbis	PINB,SWITCH3
0000a8 c003      	rjmp	screcal
         
0000a9 952a      	dec	A3
         
0000aa f789      	brne	scloop0
0000ab 9508      	ret
         
          screcal:
0000ac 9bb4      	sbis	PINB,SWITCH3
0000ad cffe      	rjmp	screcal
         
         ;	sub	CNT,A3
         ;	out	EEAR,curC
         ;	out	EEDR,CNT
         ;	sbi	EECR,EEWE
         ;scrc01:
         ;	sbic	EECR,EEWE
         ;	rjmp	scrc01
         
0000ae   +  	LIGHTBOTH
0000ae 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000af   +  	WAITMS	125
0000af e7ed      	ldi	X,0x7d
0000b0 df50      	rcall	waitxms
          .endmacro
0000b1   +  	LIGHTGRN
0000b1 98bb      	cbi	DDRB,LEDBIT
          .endmacro
0000b2   +  	WAITMS	125
0000b2 e7ed      	ldi	X,0x7d
0000b3 df4d      	rcall	waitxms
          .endmacro
0000b4   +  	LIGHTBOTH
0000b4 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000b5   +  	WAITMS	125
0000b5 e7ed      	ldi	X,0x7d
0000b6 df4a      	rcall	waitxms
          .endmacro
0000b7   +  	LIGHTGRN
0000b7 98bb      	cbi	DDRB,LEDBIT
          .endmacro
0000b8   +  	WAITMS	125
0000b8 e7ed      	ldi	X,0x7d
0000b9 df47      	rcall	waitxms
          .endmacro
0000ba   +  	LIGHTBOTH
0000ba 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000bb   +  	WAITMS	125
0000bb e7ed      	ldi	X,0x7d
0000bc df44      	rcall	waitxms
          .endmacro
0000bd   +  	LIGHTGRN
0000bd 98bb      	cbi	DDRB,LEDBIT
          .endmacro
0000be   +  	WAITMS	125
0000be e7ed      	ldi	X,0x7d
0000bf df41      	rcall	waitxms
          .endmacro
0000c0   +  	LIGHTBOTH
0000c0 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000c1   +  	WAITMS	125
0000c1 e7ed      	ldi	X,0x7d
0000c2 df3e      	rcall	waitxms
          .endmacro
0000c3   +  	LIGHTGRN
0000c3 98bb      	cbi	DDRB,LEDBIT
          .endmacro
0000c4   +  	WAITMS	125
0000c4 e7ed      	ldi	X,0x7d
0000c5 df3b      	rcall	waitxms
          .endmacro
0000c6   +  	LIGHTBOTH
0000c6 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000c7   +  	WAITMS	125
0000c7 e7ed      	ldi	X,0x7d
0000c8 df38      	rcall	waitxms
          .endmacro
0000c9   +  	LIGHTGRN
0000c9 98bb      	cbi	DDRB,LEDBIT
          .endmacro
0000ca   +  	WAITMS	125
0000ca e7ed      	ldi	X,0x7d
0000cb df35      	rcall	waitxms
          .endmacro
0000cc   +  	LIGHTBOTH
0000cc 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000cd   +  	WAITMS	125
0000cd e7ed      	ldi	X,0x7d
0000ce df32      	rcall	waitxms
          .endmacro
0000cf   +  	LIGHTGRN
0000cf 98bb      	cbi	DDRB,LEDBIT
          .endmacro
0000d0   +  	WAITMS	125
0000d0 e7ed      	ldi	X,0x7d
0000d1 df2f      	rcall	waitxms
          .endmacro
         
0000d2 9508      	ret
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'clight'
         ;*
         ;* This subroutine will set the color of the color LED to one of three states:
         ;* red, green or both
         ;*
         ;***************************************************************************
         
          clight:
0000d3 956a      	dec	K
0000d4 f011      	breq	low
0000d5 9abb      	sbi	DDRB,LEDBIT
0000d6 f411      	brne	cret
0000d7 98bb      low:	cbi	DDRB,LEDBIT
0000d8 e062      	ldi	K,2
0000d9 9508      cret:	ret
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'cont'
         ;*
         ;* This subroutine will do whatever the processor is supposed to do after
         ;* sending the code for the specified time. For now this means to loop,
         ;* possibly restarting on reset or "open lid"
         ;*
         ;***************************************************************************
         
          cont:
0000da   +  	DEBLANK
0000da 9892      	cbi	PORTD,BLANK
0000db 988a      	cbi	DDRD,BLANK
          .endmacro
0000dc 988b      	cbi	DDRD,PORTBIT
0000dd 9893      	cbi	PORTD,PORTBIT
0000de 988d      	cbi	DDRD,JUMPOUT
0000df 988c      	cbi	DDRD,JUMPIN
0000e0 9894      	cbi	PORTD,JUMPIN
0000e1 9895      	cbi	PORTD,JUMPOUT
         
          cont0:
0000e2 9b81      	sbis	PIND,RSIG
0000e3 c005      	rjmp	rcheck
0000e4 9980      	sbic	PIND,LSIG
0000e5 c009      	rjmp	lcheck
0000e6 9bb4      	sbis	PINB,SWITCH3
0000e7 c00d      	rjmp	countup
0000e8 cff9      	rjmp	cont0
         
         ; Wait for Reset button release
          rcheck:
0000e9   +  	WAITMS	1
0000e9 e0e1      	ldi	X,0x1
0000ea df16      	rcall	waitxms
          .endmacro
0000eb   +  	LIGHTBOTH
0000eb 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000ec 9b81      	sbis	PIND,RSIG
0000ed cffb      	rjmp	rcheck
0000ee c02f      	rjmp	START
         	
         ; Wait for Close
          lcheck:
0000ef   +  	WAITMS	1
0000ef e0e1      	ldi	X,0x1
0000f0 df10      	rcall	waitxms
          .endmacro
0000f1   +  	LIGHTBOTH
0000f1 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000f2 9980      	sbic	PIND,LSIG
0000f3 cffb      	rjmp	lcheck
0000f4 c029      	rjmp	START
         
         ; Increase the current COUNT value by 10 if the
         ; calibrate button is pressed.
         
          countup:
0000f5 9bb4      	sbis	PINB,SWITCH3
0000f6 cffe      	rjmp	countup
         
         ;	subi	CNT,-10
         ;	out	EEAR,curC
         ;	out	EEDR,CNT
         ;	sbi	EECR,EEWE
         ;cu01:
         ;	sbic	EECR,EEWE
         ;	rjmp	cu01
         
0000f7   +  	LIGHTBOTH
0000f7 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000f8   +  	WAITMS	125
0000f8 e7ed      	ldi	X,0x7d
0000f9 df07      	rcall	waitxms
          .endmacro
0000fa   +  	LIGHTGRN
0000fa 98bb      	cbi	DDRB,LEDBIT
          .endmacro
0000fb   +  	WAITMS	125
0000fb e7ed      	ldi	X,0x7d
0000fc df04      	rcall	waitxms
          .endmacro
0000fd   +  	LIGHTBOTH
0000fd 9abb      	sbi	DDRB,LEDBIT
          .endmacro
0000fe   +  	WAITMS	125
0000fe e7ed      	ldi	X,0x7d
0000ff df01      	rcall	waitxms
          .endmacro
000100   +  	LIGHTGRN
000100 98bb      	cbi	DDRB,LEDBIT
          .endmacro
000101   +  	WAITMS	125
000101 e7ed      	ldi	X,0x7d
000102 defe      	rcall	waitxms
          .endmacro
000103   +  	LIGHTBOTH
000103 9abb      	sbi	DDRB,LEDBIT
          .endmacro
000104   +  	WAITMS	125
000104 e7ed      	ldi	X,0x7d
000105 defb      	rcall	waitxms
          .endmacro
000106   +  	LIGHTGRN
000106 98bb      	cbi	DDRB,LEDBIT
          .endmacro
000107   +  	WAITMS	125
000107 e7ed      	ldi	X,0x7d
000108 def8      	rcall	waitxms
          .endmacro
000109   +  	LIGHTBOTH
000109 9abb      	sbi	DDRB,LEDBIT
          .endmacro
00010a   +  	WAITMS	125
00010a e7ed      	ldi	X,0x7d
00010b def5      	rcall	waitxms
          .endmacro
00010c   +  	LIGHTGRN
00010c 98bb      	cbi	DDRB,LEDBIT
          .endmacro
00010d   +  	WAITMS	125
00010d e7ed      	ldi	X,0x7d
00010e def2      	rcall	waitxms
          .endmacro
00010f   +  	LIGHTBOTH
00010f 9abb      	sbi	DDRB,LEDBIT
          .endmacro
000110   +  	WAITMS	125
000110 e7ed      	ldi	X,0x7d
000111 deef      	rcall	waitxms
          .endmacro
000112   +  	LIGHTGRN
000112 98bb      	cbi	DDRB,LEDBIT
          .endmacro
000113   +  	WAITMS	125
000113 e7ed      	ldi	X,0x7d
000114 deec      	rcall	waitxms
          .endmacro
000115   +  	LIGHTBOTH
000115 9abb      	sbi	DDRB,LEDBIT
          .endmacro
000116   +  	WAITMS	125
000116 e7ed      	ldi	X,0x7d
000117 dee9      	rcall	waitxms
          .endmacro
000118   +  	LIGHTGRN
000118 98bb      	cbi	DDRB,LEDBIT
          .endmacro
000119   +  	WAITMS	125
000119 e7ed      	ldi	X,0x7d
00011a dee6      	rcall	waitxms
          .endmacro
         
00011b cfc6      	rjmp	cont0
         	
         
         ;****************************************************************************
         ;*
         ;* Subroutine 'passive'
         ;*
         ;* This subroutine will just put the 'chip' in passive, tristate mode.
         ;* LED will be red
         ;*
         ;***************************************************************************
         
          passive:
00011c   +  	LIGHTOFF
00011c 98bb      	cbi	DDRB,LEDBIT
          .endmacro
         
00011d cfbc      	rjmp	cont
         
         ;****************************************************************************
         ;*
         ;* Main Program
         ;*
         ;* This program calls the routines "sysinit", "init", "sendcode" and "cont"
         ;* in that order.
         ;*
         ;***************************************************************************
         
         ;***** Main Program Register Variables
         
          START:
         ; Init ports
00011e df56      	rcall sysinit
         ; Do the initial signalling. The LED will be set to green after this
00011f df69      	rcall init
000120 df7a      	rcall	sendcode
         
000121   +  	LIGHTGRN
000121 98bb      	cbi	DDRB,LEDBIT
          .endmacro
         
         ; ..and go wait for better weather or possibly a RESET
000122 cfb7      	rjmp	cont

Assembly complete with no errors.
